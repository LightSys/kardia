$Version=2$
update_duplicates "system/query"
    {
    // This script updates the p_dup table (/apps/kardia/data/Kardia_DB/p_dup/rows)
    // by detecting duplicates using two strategies (aggregation and concatenation)
    // and then upserting the results into the table.
    // 
    // The aggregation strategy first searches for dups on several groups of fields
    // which it fetches using name.qy, name_metas.qy, emails.qy, phones.qy, and
    // addresses.qy.  We invoke the dups.cluster file to get a list of dups for each
    // of these field groups (name_dups, email_dups, etc.).  Then, add each dup found
    // by the other strategies to name_dups by computing its name similarity.  Next,
    // we add each dup in name_dups to each other collection by computing the
    // similarity of the respective fields.  Thus, every dup exists in all five
    // collections.  Finally, we aggregate these collections using this equation:
    // `average(max(name_sim, name_meta_sim * 0.9), email_sim, phone_sim, address_sim)`
    // If a field is missing (e.g. either possible dup record doesn't have an email),
    // we use a value of -1, and all values less than 0 are ignored by the average.
    // (This avoids overlooking records that are missing a lot of data.)
    // 
    // The concatenation strategy is simpler.  We simply concatenate all relevant
    // fields (collection concats), then search for dups (collection concat_dups)
    // on the concatinated data.
    // 
    // Each strategy has pros and cons.
    //   - Aggregation avoids overlooking records when one is missing information.
    //   - Aggregation provides clearer reasoning to the database administrator.
    //   - Aggregation can use Levenstein for some fields (name meta and phone),
    //     and cosine for others.  Contamination uses the same measure for everything.
    //   - Concatenation finds dups where someone's email is similar to another
    //     person's name, which can tip us off to relationships we'd otherwise miss.
    //   - Concatenation is slightly faster, so it can be run with a lower threshold,
    //     making it more sensitive to near dups in some cases. 
    //   - Concatenation is prone to cryptic false positives.
    // 
    // In short, aggregation gives us more control, allowing us to find far more dups,
    // but it comes at a cost of greater complexity, slower compute times, and missing
    // certain specific cases of duplicates.
    // 
    // Note: If concat_dups detects a dup, we also run run the other field checks on it
    //       even though concatenation similarity is not used in the aggregation equation.
    //       This is because it helps to enhance the reason field with additional info
    //       that the database administrator can see at a glace.
    
    sql = "
	DECLARE object value;
	
	-- The number of places to show after the decimal point for reason
	-- similarity percentages.
	SELECT :value:reason_decimals = 1;
	
	-- The minimum aggregated similarity threshold that must be reached
	-- for a duplicate to be added to the table and displayed to the user.
	-- Duplicates which aggregate to a lower similarity than this do are
	-- dropped before being added even if one attribute happens to have a
	-- has high similarity.
	-- For other similarity thresholds, see `dups.cluster`.
	SELECT :value:min_total_sim = 0.60;
	
	print 'Getting data...'
	-- Get collections for each set of possible dups.
	DECLARE collection names;
	DECLARE collection name_metas;
	DECLARE collection emails;
	DECLARE collection phones;
	DECLARE collection addresses;
	DECLARE collection concats;
	INSERT INTO collection names      SELECT :key, :name      FROM /apps/kardia/modules/base/dups/get/names.qy ;
	INSERT INTO collection name_metas SELECT :key, :name_meta FROM /apps/kardia/modules/base/dups/get/name_metas.qy ;
	INSERT INTO collection emails     SELECT :key, :email     FROM /apps/kardia/modules/base/dups/get/emails.qy ;
	INSERT INTO collection phones     SELECT :key, :phone     FROM /apps/kardia/modules/base/dups/get/phones.qy ;
	INSERT INTO collection addresses  SELECT :key, :address   FROM /apps/kardia/modules/base/dups/get/addresses.qy ;
	INSERT INTO collection concats    SELECT :key, :data      FROM /apps/kardia/modules/base/dups/get/concats.qy ;
	
	print 'Counting data...'
	-- Count data.
	SELECT :value:names_count      = count(1) FROM collection names;
	SELECT :value:name_metas_count = count(1) FROM collection name_metas;
	SELECT :value:emails_count     = count(1) FROM collection emails;
	SELECT :value:phones_count     = count(1) FROM collection phones;
	SELECT :value:addresses_count  = count(1) FROM collection addresses;
	SELECT :value:concats_count    = count(1) FROM collection concats;
	
	print 'Computing search parameters...'
	-- Compute searching parameters.
	SELECT
	    :value:names_algorithm = :names:algorithm,
	    :value:name_metas_algorithm = :name_metas:algorithm,
	    :value:emails_algorithm = :emails:algorithm,
	    :value:phones_algorithm = :phones:algorithm,
	    :value:addresses_algorithm = :addresses:algorithm,
	    :value:concats_algorithm = :concats:algorithm,
	    :value:names_k = :names:k,
	    :value:name_metas_k = :name_metas:k,
	    :value:emails_k = :emails:k,
	    :value:phones_k = :phones:k,
	    :value:addresses_k = :addresses:k,
	    :value:concats_k = :concats:k
	FROM
	    expression ('/apps/kardia/modules/base/dups/cluster_params.qy?num_data=' + :value:names_count) names,
	    expression ('/apps/kardia/modules/base/dups/cluster_params.qy?num_data=' + :value:name_metas_count) name_metas,
	    expression ('/apps/kardia/modules/base/dups/cluster_params.qy?num_data=' + :value:emails_count) emails,
	    expression ('/apps/kardia/modules/base/dups/cluster_params.qy?num_data=' + :value:phones_count) phones,
	    expression ('/apps/kardia/modules/base/dups/cluster_params.qy?num_data=' + :value:addresses_count) addresses,
	    expression ('/apps/kardia/modules/base/dups/cluster_params.qy?num_data=' + :value:concats_count) concats
	;
	
	
	print 'Searching for name dups...'
	-- Get name_dups using the dups.cluster file.
	DECLARE collection name_dups;
	INSERT INTO
	    collection name_dups
	SELECT
	    :key1,
	    :key2,
	    :sim
	FROM
	    identity expression (
		'/apps/kardia/modules/base/dups/dups.cluster'
		    + '?algorithm=' + :value:names_algorithm
		    + '&k=' + :value:names_k
		    + '&field=names'
		    + '&data=name'
		+ '/dups'
	    )
	;
	
	print 'Searching for name_meta dups...'
	-- Get name_meta_dups using the dups.cluster file.
	DECLARE collection name_meta_dups;
	INSERT INTO
	    collection name_meta_dups
	SELECT
	    key1 = :key1,
	    key2 = :key2,
	    sim = :sim
	FROM
	    identity expression (
		'/apps/kardia/modules/base/dups/dups.cluster'
		    + '?algorithm=' + :value:name_metas_algorithm
		    + '&k=' + :value:name_metas_k
		    + '&field=name_metas'
		    + '&data=name_meta'
		+ '/meta_dups'
	    )
	;
	
	print 'Searching for email dups...'
	-- Get email_dups using the dups.cluster file.
	DECLARE collection email_dups;
	INSERT INTO
	    collection email_dups
	SELECT
	    key1 = :d:key1,
	    key2 = :d:key2,
	    sim = max(:d:sim)
	FROM
	    identity expression (
		'/apps/kardia/modules/base/dups/dups.cluster'
		    + '?algorithm=' + :value:emails_algorithm
		    + '&k=' + :value:emails_k
		    + '&field=emails'
		    + '&data=email'
		+ '/dups'
	    ) d
	GROUP BY
	    :d:key1,
	    :d:key2
	;
	
	print 'Searching for phone dups...'
	-- Get email_dups using the dups.cluster file.
	DECLARE collection phone_dups;
	INSERT INTO
	    collection phone_dups
	SELECT
	    key1 = :d:key1,
	    key2 = :d:key2,
	    sim = max(:d:sim)
	FROM
	    expression (
		'/apps/kardia/modules/base/dups/dups.cluster'
		    + '?algorithm=' + :value:phones_algorithm
		    + '&k=' + :value:phones_k
		    + '&field=phones'
		    + '&data=phone'
		+ '/phone_dups'
	    ) d
	GROUP BY
	    :d:key1,
	    :d:key2
	;
	
	print 'Searching for address dups...'
	-- Get address_dups using the dups.cluster file.
	DECLARE collection address_dups;
	INSERT INTO
	    collection address_dups
	SELECT
	    key1 = :d:key1,
	    key2 = :d:key2,
	    sim = max(:d:sim)
	FROM
	    identity expression (
		'/apps/kardia/modules/base/dups/dups.cluster'
		    + '?algorithm=' + :value:addresses_algorithm
		    + '&k=' + :value:addresses_k
		    + '&field=addresses'
		    + '&data=address'
		+ '/dups'
	    ) d
	GROUP BY
	    :d:key1,
	    :d:key2
	;
	
	print 'Searching for concat dups...'
	-- Get concat_dups using the dups.cluster file.
	DECLARE COLLECTION concat_dups;
	INSERT INTO
	    collection concat_dups
	SELECT
	    key1 = :d:key1,
	    key2 = :d:key2,
	    sim = max(:d:sim)
	FROM
	    identity expression (
		'/apps/kardia/modules/base/dups/dups.cluster'
		    + '?algorithm=' + :value:concats_algorithm
		    + '&k=' + :value:concats_k
		    + '&field=concats'
		    + '&data=data'
		+ '/concat_dups'
	    ) d
	GROUP BY
	    :d:key1,
	    :d:key2
	;
	
	
	print 'Adding other collections dups to name dups...'
	-- [name_dups <- name_meta_dups] Add an entry to name_dups for each entry in name_meta_dups.
	INSERT INTO
	    collection name_dups
	SELECT
	    key1 = :name_meta:key1,
	    key2 = :name_meta:key2,
	    sim = condition(:name:sim >= 0.0,
		:name:sim,
		isnull(cos_compare(:n1:name, :n2:name), -1.0)
	    )
	FROM
	    identity collection name_meta_dups name_meta,
	    collection name_dups name,
	    collection names n1,
	    collection names n2
	WHERE
	    :name_meta:key1 *= :name:key1
	AND :name_meta:key2 *= :name:key2
	AND :name_meta:key1 *= :n1:key
	AND :name_meta:key2 *= :n2:key
	ON duplicate -- Update entries that already exist (in case we have a cross-cluster match).
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:name:sim >= 0.0,
		:name:sim,
		isnull(cos_compare(:n1:name, :n2:name), -1.0)
	    )
	;
	
	-- [name_dups <- email_dups] Add an entry to name_dups for each entry in email_dups.
	INSERT INTO
	    collection name_dups
	SELECT
	    key1 = :email:key1,
	    key2 = :email:key2,
	    sim = condition(:name:sim >= 0.0,
		:name:sim,
		isnull(cos_compare(:n1:name, :n2:name), -1.0)
	    )
	FROM
	    identity collection email_dups email,
	    collection name_dups name,
	    collection names n1,
	    collection names n2
	WHERE
	    :email:key1 *= :name:key1
	AND :email:key2 *= :name:key2
	AND :email:key1 *= :n1:key
	AND :email:key2 *= :n2:key
	ON duplicate -- Update entries that already exist (in case we have a cross-cluster match).
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:name:sim >= 0.0,
		:name:sim,
		isnull(cos_compare(:n1:name, :n2:name), -1.0)
	    )
	;
	
	-- [name_dups <- phone_dups] Add an entry to name_dups for each entry in phone_dups.
	INSERT INTO
	    collection name_dups
	SELECT
	    key1 = :phone:key1,
	    key2 = :phone:key2,
	    sim = condition(:name:sim >= 0.0,
		:name:sim,
		max(isnull(cos_compare(:n1:name, :n2:name), -1.0))
	    )
	FROM
	    identity collection phone_dups phone,
	    collection name_dups name,
	    collection names n1,
	    collection names n2
	WHERE
	    :phone:key1 *= :name:key1
	AND :phone:key2 *= :name:key2
	AND :phone:key1 *= :n1:key
	AND :phone:key2 *= :n2:key
	GROUP BY
	    :name:key1,
	    :name:key2
	ON duplicate -- Update entries that already exist (in case we have a cross-cluster match).
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:name:sim >= 0.0,
		:name:sim,
		max(isnull(cos_compare(:n1:name, :n2:name), -1.0))
	    )
	;
	
	-- [name_dups <- address_dups] Add an entry to name_dups for each entry in address_dups.
	INSERT INTO
	    collection name_dups
	SELECT
	    key1 = :address:key1,
	    key2 = :address:key2,
	    sim = condition(:name:sim >= 0.0,
		:name:sim,
		max(isnull(cos_compare(:n1:name, :n2:name), -1.0))
	    )
	FROM
	    identity collection address_dups address,
	    collection name_dups name,
	    collection names n1,
	    collection names n2
	WHERE
	    :address:key1 *= :name:key1
	AND :address:key2 *= :name:key2
	AND :address:key1 *= :n1:key
	AND :address:key2 *= :n2:key
	GROUP BY
	    :name:key1,
	    :name:key2
	ON duplicate -- Update entries that already exist (in case we have a cross-cluster match).
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:name:sim >= 0.0,
		:name:sim,
		max(isnull(cos_compare(:n1:name, :n2:name), -1.0))
	    )
	;
	
	-- [name_dups <- concat_dups] Add an entry to name_dups for each entry in concat_dups.
	-- This isn't strictly necessary because concat_dups isn't used in the final aggregation.
	-- However, it can sometimes provide additional information in the 'reason' column of the
	-- UI, so this feels like it's worth the small cost in extra computation. 
	INSERT INTO
	    collection name_dups
	SELECT
	    key1 = :concat:key1,
	    key2 = :concat:key2,
	    sim = condition(:name:sim >= 0.0,
		:name:sim,
		isnull(cos_compare(:n1:name, :n2:name), -1.0)
	    )
	FROM
	    identity collection concat_dups concat,
	    collection name_dups name,
	    collection names n1,
	    collection names n2
	WHERE
	    :concat:key1 *= :name:key1
	AND :concat:key2 *= :name:key2
	AND :concat:key1 *= :n1:key
	AND :concat:key2 *= :n2:key
	ON duplicate -- Update entries that already exist (in case we have a cross-cluster match).
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:name:sim >= 0.0,
		:name:sim,
		isnull(cos_compare(:n1:name, :n2:name), -1.0)
	    )
	;
	
	
	print 'Adding name dups to other collections...'
	-- [name_meta_dups <- name_dups] Add an entry to name_meta_dups for each entry in name_dups.
	INSERT INTO
	    collection name_meta_dups
	SELECT
	    key1 = :name:key1,
	    key2 = :name:key2,
	    sim = condition(:name_meta:sim >= 0.0,
		:name_meta:sim,
		isnull(lev_compare(:nm1:name_meta, :nm2:name_meta), -1.0)
	    )
	FROM
	    identity collection name_dups name,
	    collection name_meta_dups name_meta,
	    collection name_metas nm1,
	    collection name_metas nm2
	WHERE
	    :name:key1 *= :name_meta:key1
	AND :name:key2 *= :name_meta:key2
	AND :name:key1 *= :nm1:key
	AND :name:key2 *= :nm2:key
	GROUP BY
	    :name:key1,
	    :name:key2
	ON duplicate -- Skip duplicate entries.
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:name_meta:sim >= 0.0,
		:name_meta:sim,
		isnull(lev_compare(:nm1:name_meta, :nm2:name_meta), -1.0)
	    )
	;
	
	-- [email_dups <- name_dups] Add an entry to email_dups for each entry in name_dups.
	INSERT INTO
	    collection email_dups
	SELECT
	    key1 = :name:key1,
	    key2 = :name:key2,
	    sim = condition(:email:sim >= 0.0,
		:email:sim,
		max(isnull(cos_compare(:e1:email, :e2:email), -1.0))
	    )
	FROM
	    identity collection name_dups name,
	    collection email_dups email,
	    collection emails e1,
	    collection emails e2
	WHERE
	    :name:key1 *= :email:key1
	AND :name:key2 *= :email:key2
	AND :name:key1 *= :e1:key
	AND :name:key2 *= :e2:key
	GROUP BY
	    :name:key1,
	    :name:key2
	ON duplicate -- Skip duplicate entries.
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:email:sim >= 0.0,
		:email:sim,
		max(isnull(cos_compare(:e1:email, :e2:email), -1.0))
	    )
	;
	
	-- [phone_dups <- name_dups] Add an entry to phone_dups for each entry in name_dups.
	INSERT INTO
	    collection phone_dups
	SELECT
	    key1 = :name:key1,
	    key2 = :name:key2,
	    sim = condition(:phone:sim >= 0.0,
		:phone:sim,
		max(isnull(lev_compare(:ph1:phone, :ph2:phone), -1.0))
	    )
	FROM
	    identity collection name_dups name,
	    collection phone_dups phone,
	    collection phones ph1,
	    collection phones ph2
	WHERE
	    :name:key1 *= :phone:key1
	AND :name:key2 *= :phone:key2
	AND :name:key1 *= :ph1:key
	AND :name:key2 *= :ph2:key
	GROUP BY
	    :name:key1,
	    :name:key2
	ON duplicate -- Skip duplicate entries.
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:phone:sim >= 0.0,
		:phone:sim,
		max(isnull(lev_compare(:ph1:phone, :ph2:phone), -1.0))
	    )
	;
	
	-- [address_dups <- name_dups] Add an entry to address_dups for each entry in name_dups.
	INSERT INTO
	    collection address_dups
	SELECT
	    key1 = :name:key1,
	    key2 = :name:key2,
	    sim = condition(:address:sim >= 0.0,
		:address:sim,
		max(isnull(cos_compare(:l1:address, :l2:address), -1.0))
	    )
	FROM
	    identity collection name_dups name,
	    collection address_dups address,
	    collection addresses l1,
	    collection addresses l2
	WHERE
	    :name:key1 *= :address:key1
	AND :name:key2 *= :address:key2
	AND :name:key1 *= :l1:key
	AND :name:key2 *= :l2:key
	GROUP BY
	    :name:key1,
	    :name:key2
	ON duplicate -- Skip duplicate entries.
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:address:sim >= 0.0,
		:address:sim,
		max(isnull(cos_compare(:l1:address, :l2:address), -1.0))
	    )
	;
	
	-- Free application-scoped collections.
	DELETE FROM collection names;
	DELETE FROM collection name_metas;
	DELETE FROM collection emails;
	DELETE FROM collection phones;
	DELETE FROM collection addresses;
	
	-- Declare a collection to hold all dups found by both strategies (aggregation and concatenation).
	DECLARE collection all_dups;
	
	print 'Aggregating dups...'
	-- Aggregate dups.
	INSERT INTO
	    collection all_dups
	SELECT
	    key1 = :name:key1,
	    key2 = :name:key2,
	    sim = (0.0
		+ condition(constrain(:name:sim, :name_meta:sim * 0.9, 1.0) >= 0.0, constrain(:name:sim, :name_meta:sim * 0.9, 1.0), 0.0)
		+ condition(:email:sim >= 0.0, :email:sim, 0.0)
		+ condition(:phone:sim >= 0.0, :phone:sim, 0.0)
		+ condition(:address:sim >= 0.0, :address:sim, 0.0)
	    ) / (constrain(0.0 -- Constrain to prevent divide by 0 when NANs wander into the data from alternate dimensions.
		+ condition(:name:sim >= 0.0 OR :name_meta:sim >= 0.0, 1.0, 0.0)
		+ condition(:email:sim >= 0.0, 1.0, 0.0)
		+ condition(:phone:sim >= 0.0, 1.0, 0.0)
		+ condition(:address:sim >= 0.0, 1.0, 0.0)
		, 0.0000001, convert(double, NULL)) -- Necessary because centrallix devision does not handle NAN properly.
	    ),
	    reason = ''
		+ condition(:name:sim > 0.0, 'Name (' + round(:name:sim * 100, :value:reason_decimals) + '%)\\n', '')
		+ condition(:name_meta:sim > 0.0 AND (:name_meta:sim - 0.00001) > :name:sim, 'Phonetic Name (' + round(:name_meta:sim * 100, :value:reason_decimals) + '%)\\n', '')
		+ condition(:email:sim > 0.0, 'Email (' + round(:email:sim * 100, :value:reason_decimals) + '%)\\n', '')
		+ condition(:phone:sim > 0.0, 'Phone (' + round(:phone:sim * 100, :value:reason_decimals) + '%)\\n', '')
		+ condition(:address:sim > 0.0, 'Address (' + round(:address:sim * 100, :value:reason_decimals) + '%)\\n', '')
		- '\\n'
	FROM
	    identity collection name_dups name,
	    collection name_meta_dups name_meta,
	    collection email_dups email,
	    collection phone_dups phone,
	    collection address_dups address
	WHERE
	    :name:key1 = :name_meta:key1
	AND :name:key2 = :name_meta:key2
	AND :name:key1 = :email:key1
	AND :name:key2 = :email:key2
	AND :name:key1 = :phone:key1
	AND :name:key2 = :phone:key2
	AND :name:key1 = :address:key1
	AND :name:key2 = :address:key2
	;
	
	
	print 'Adding concatenation dups...'
	-- Full Concat Dups
	INSERT INTO
	    collection all_dups
	SELECT
	    key1 = :concat:key1,
	    key2 = :concat:key2,
	    sim = :concat:sim,
	    reason = 'All (' + round(:concat:sim * 100, :value:reason_decimals) + '%)'
	FROM
	    identity collection concat_dups concat
	ON duplicate
	    :key1,
	    :key2
	UPDATE SET
	    :sim = condition(:sim > :concat:sim, :sim, :concat:sim),
	    :reason = 'All (' + round(:concat:sim * 100, :value:reason_decimals) + '%)\\n' + :reason,
	    :s_date_modified = getdate(),
	    :s_modified_by = user_name()
	;
	
	
	-- Remove all data from the dups table (for debugging).
	delete from /apps/kardia/data/Kardia_DB/p_dup/rows ;
	
	print 'Storing dups...'
	-- TODO: Greg - We should fix this upsert.
	-- Insert dups into p_dup table.
	INSERT INTO
	    /apps/kardia/data/Kardia_DB/p_dup/rows
	SELECT
	    p_partner_key = :key1,
	    p_dup_partner_key = :key2,
	    p_match_quality = :sim,
	    p_reason = :reason,
	    
	    -- Required fields.
	    s_date_created = getdate(),
	    s_created_by = user_name(),
	    s_date_modified = getdate(),
	    s_modified_by = user_name()
	FROM
	    collection all_dups
	WHERE -- We should never get identical dups, but somehow we do. This fixes that issue.
	    :all_dups:key1 != :all_dups:key2
	AND :sim > :value:min_total_sim
	ON duplicate
	    :p_partner_key,
	    :p_dup_partner_key
	UPDATE SET
	    :p_match_quality = :sim,
	    :p_reason = :reason,
	    :s_date_modified = getdate(),
	    :s_modified_by = user_name()
	;
	
	-- Remove stale data from the dups table.
--	DELETE
--	FROM
--	    identity /apps/kardia/data/Kardia_DB/p_dup/rows d,
--	    /apps/kardia/data/Kardia_DB/p_partner/rows p1,
--	    /apps/kardia/data/Kardia_DB/p_partner/rows p2
--	WHERE
--	    :d:p_partner_key *= :p1:p_partner_key
--	AND :d:p_dup_partner_key *= :p2:p_partner_key
--	AND(:d:s_date_modified < isnull(:p1:s_date_modified, getdate())
--	    OR :d:s_date_modified < isnull(:p2:s_date_modified, getdate()))
--	;
	print 'Update complete'
    ";
    }
