
$Version=2$
myquery "system/query"
    {
    sql = "
	    -- get the login info. Gets new session every time so there is no need to worry about expired keys
	    DECLARE OBJECT vancoKey;
	    SELECT 
	        :vancoKey:value = :SessionID,
		:vancoKey:lookback = convert( 'integer', (
		    select first(:a_config_value)
		    from /apps/kardia/data/Kardia_DB/a_config/rows
		    where :a_config_name = 'VP_Lookback'
		    )),
		:vancoKey:fromDate = dateformat(
		    dateadd('day', 
			-1 * convert( 'integer', (
			    select first(:a_config_value)
			    from /apps/kardia/data/Kardia_DB/a_config/rows
			    where :a_config_name = 'VP_Lookback'
			    )),
			convert('datetime', isnull((select first(:a_config_value) from /apps/kardia/data/Kardia_DB/a_config/rows where :a_config_name = 'VP_StartDate'),getdate()))
		    ),
		    'yyyy-MM-dd'),
		:vancoKey:toDate = dateformat(isnull((select first(:a_config_value) from /apps/kardia/data/Kardia_DB/a_config/rows where :a_config_name = 'VP_StartDate'), getdate()), 'yyyy-MM-dd')
            FROM
                /apps/kardia/modules/eg_vanco/egvapi_login.http
            ;

	    -- get the fund histories
	    DECLARE COLLECTION dataQuery;
	    INSERT 
		COLLECTION dataQuery
	    SELECT 
		-- use the path to set the dense_rank. Use all for transactions, and everthing before /Funds/Fund in funds
		transGroup = dense_rank(condition(charindex('/Funds/Fund', :__cx_path) > 0, 
			substring(:__cx_path, 35, charindex('/Funds/Fund', :__cx_path) - 35), 
			substring(:__cx_path, 35)
		)),
		cx_path=:__cx_path, -- include for debug
		:TransactionRef, :CustomerID, :CustomerRef, :PaymentMethodRef, :ProcessDate, :SettlementDate,
		:DepositDate, :CCAuthDesc, :CCStatus, :Amount, :TransactionFee, :FundID, :FundName, :FundAmount, 
		:FundTransactionFee, :FundNote, :Credit, :ReturnDate, :ReturnCode, 
		:ReturnReason
	    FROM 
		IDENTITY SUBTREE PAGED EXPRESSION(
		    '/apps/kardia/modules/eg_vanco/egvapi_transFundHist.http?VancoWS.Auth.SessionID='
		    +:vancoKey:value+'&VancoWS.Request.RequestVars.FromDate='
		    +dateformat(dateadd('day', -1*(:dq:cx__page - 1), :vancoKey:toDate), 'yyyy-MM-dd')
		    +'&VancoWS.Request.RequestVars.ToDate='
		    +condition(:dq:cx__page <= :vancoKey:lookback + 1, 
			dateformat(dateadd('day', -1*(:dq:cx__page - 1), :vancoKey:toDate), 'yyyy-MM-dd'),
			'not-a-date')) dq
		
	    where
		:dq:TransactionRef IS NOT NULL OR :dq:FundID IS NOT NULL OR :dq:TransactionCount = 0
	    ;

	    -- run a join to combine transactions and funds into one line per fund gift. Joins based on transaction group 
	    DECLARE COLLECTION transactions;
	    INSERT 
		COLLECTION transactions
	    SELECT
		transPath = :t:cx_path, fundPath = :f:cx_path, :t:transGroup,
		:t:TransactionRef, :t:CustomerID, :t:CustomerRef, :t:PaymentMethodRef, :t:ProcessDate, :t:SettlementDate,
		:t:DepositDate, :t:CCAuthDesc, :t:CCStatus, :t:Amount, :t:TransactionFee, :f:FundID, :f:FundName, :f:FundAmount, 
		:f:FundTransactionFee, :f:FundNote, :t:Credit, :t:ReturnDate, :t:ReturnCode, 
		:t:ReturnReason
	    FROM
		IDENTITY COLLECTION dataQuery t,
		COLLECTION dataQuery f
	    WHERE 
	    	-- make sure to just allow transactions for t
		charindex('Funds/Fund', :t:cx_path) = 0
		-- only allow funds for f
		AND charindex('Funds/Fund', :f:cx_path) > 0
		-- join based on the fund sharing a transGroup with the transaction 
		AND :t:transGroup = :f:transGroup
	    ;

	    DECLARE COLLECTION custRefList SCOPE APPLICATION;
	    INSERT
		collection custRefList
	    SELECT 
		:CustomerRef
	    FROM
		COLLECTION transactions
	    GROUP BY
		:CustomerRef
	    ;
	    
	    -- report the number of custoners and transactions. Helps with debug and expectations for runtime
	    SELECT 
		:vancoKey:numCustomers = count(1)
	    FROM 
		COLLECTION custRefList
	    ;

	    SELECT 
		:vancoKey:numTransactions = count(1)
	    FROM 
		COLLECTION transactions
	    ;

	    print 'number of customers: '+:vancoKey:numCustomers
	    print 'number of transactions: '+:vancoKey:numTransactions

	    -- check for reacurring transactions from the customers
	    DECLARE COLLECTION currentTransactionsRaw;
	    INSERT 
	        COLLECTION currentTransactionsRaw
	    SELECT 
		-- use the path to control group. Empty tags get -1 for the group
		transGroup = dense_rank(condition(charindex('Transactions/', :__cx_path) = 0, -1,
			condition(charindex('/Funds', :__cx_path) > 0, 
			substring(:__cx_path, 35, charindex('/Funds', :__cx_path) - 35), 
			substring(:__cx_path, 35)
		    )
		)),
		cx_path=:ct:__cx_path, :ct:cx__page, :ct:ErrorCode, :ct:FundID, *
	    FROM 
	        SUBTREE PAGED EXPRESSION('/apps/kardia/modules/eg_vanco/egvapi_currTrans.http?VancoWS.Auth.SessionID='
		+:vancoKey:value+'&VancoWS.Request.RequestVars.CustomerRef='+
		(select nth(:crl:CustomerRef, :ct:cx__page) from collection custRefList crl)) ct
	    WHERE
		:FundID IS NOT NULL OR :TransactionRef IS NOT NULL OR :TransactionCount IS NOT NULL
	    ;
	    -- combine the funds and transactions into one row
	    DECLARE COLLECTION ongoingTransactions;
	    INSERT 
		COLLECTION ongoingTransactions
	    SELECT 
		transPath=:t:__cx_path, fundPath=:f:__cx_path, :t:transGroup, :t:TransactionRef, :t:CustomerRef, :t:PaymentMethodRef, :t:StartDate, 
		:t:EndDate, :t:Frequency, :t:FrequencyType, :t:NextProcess, :t:NextSettlement, :t:Credit,
		:f:Amount, :t:amount, :f:FundID, :f:FundName
	    FROM 
		IDENTITY COLLECTION currentTransactionsRaw t,
		COLLECTION currentTransactionsRaw f
	    WHERE
		-- make sure to just allow transactions for t
		:t:TransactionRef IS NOT NULL
		-- only allow funds for f
		AND :f:FundID IS NOT NULL
		-- join based transGroup
		AND :t:transGroup = :f:transGroup 
	    ;

	    -- now get the info on the customers
	    DECLARE COLLECTION customers;
	    INSERT 
	        COLLECTION customers
	    SELECT 
	        *
	    FROM 
	        SUBTREE PAGED EXPRESSION('/apps/kardia/modules/eg_vanco/egvapi_custInfo.http?VancoWS.Auth.SessionID='
		+:vancoKey:value+'&VancoWS.Request.RequestVars.CustomerRef='+
		(select nth(:crl:CustomerRef, :cu:cx__page) from collection custRefList crl)) cu
	    WHERE 
		:CustomerRef IS NOT NULL
	    ;

	    DECLARE COLLECTION payMethods;
	    INSERT 
	        COLLECTION payMethods
	    SELECT 
	        :pm:CustomerRef, :pm:PaymentMethodRef, :pm:AccountType, :pm:CardType, :pm:AccountNumber, :pm:ErrorCode
	    FROM 
	        SUBTREE PAGED EXPRESSION('/apps/kardia/modules/eg_vanco/egvapi_payMethod.http?VancoWS.Auth.SessionID='
		+:vancoKey:value+'&VancoWS.Request.RequestVars.CustomerRef='+
		(select nth(:crl:CustomerRef, :pm:cx__page) from collection custRefList crl)) pm
	    WHERE 
		:CustomerRef IS NOT NULL OR :ErrorCode == '167' -- allow for 'payment method not found'
	     ;

	    -- clear out global collections; no longer needed
	    DELETE FROM
		COLLECTION custRefList
	    ;

	    -- finally, join all of the data together 
	    SELECT
		-- debug values
		t_transRef = :t:TransactionRef,
		t_custRef = :t:CustomerRef,
		c_custRef = :c:CustomerRef,
		p_custRef = :p:CustomerRef,
		t_payRef = :t:PaymentMethodRef,
		p_payRef = :p:PaymentMethodRef,

		-- actual values
		i_eg_gift_uuid = condition(:o:Frequency IS NOT NULL, :o:TransactionRef, :t:TransactionRef), -- TODO: currently, :t:TransactionRef = :o:TransactionRef. Simplify if this doesn't change
		i_eg_desig_uuid = :t:FundID,
		i_eg_trx_uuid = :t:TransactionRef+'-'+dateformat(convert('datetime', :t:ProcessDate), 'yyyy-MM-dd'),
		i_eg_donor_uuid = :t:CustomerID,  
		i_eg_donor_alt_id = :t:CustomerRef,
		i_eg_account_uuid = :t:PaymentMethodRef,
		-- set status to pending if the deposit date is in the future
		i_eg_status = condition((:t:CCStatus == 'P' AND char_length(:t:ReturnCode) <= 0) OR (char_length(:t:CCStatus) <= 0), 
				condition(datediff('day', getdate(), convert('datetime', 
					condition((select first(:a_config_value) from /apps/kardia/data/Kardia_DB/a_config/rows where :a_config_name = 'VP_UseDepo') == '1',
					:t:DepositDate, :t:SettlementDate)
				)) <= 0, 'paid', 'pending'),
			'returned'), -- either return code exists or CCStatus was E or F. Either way, mark as a return 
		i_eg_returned_status = condition(:t:CCStatus == 'E', 
		    'Error', 
		    condition(:t:CCStatus == 'F', 
			'Failed', 
			condition(char_length(:t:retunredCode) > 0,
			    :t:retunredCode, 
			    NULL))),
		-- convert from 'LNAME, FNAME(and FNAME)?( MI)?' to 'FNAME(and FNAME)?( MI)? LNAME'
		i_eg_donor_name = condition(charindex(',', :c:CustomerName) == 0, :c:CustomerName, -- if no comma, likely an org.
			substring(:c:CustomerName, charindex(',', :c:CustomerName) + 2)+' '+
			substring(:c:CustomerName, 1, charindex(',', :c:CustomerName) - 1)),
		i_eg_donor_given_name =  condition(charindex(',', :c:CustomerName) == 0, NULL,
			condition(charindex(' ', reverse(:c:CustomerName)) == 2,
				substring(:c:CustomerName, charindex(',', :c:CustomerName) + 2, 
				char_length(:c:CustomerName) - charindex(',', :c:CustomerName) - 3), 
				substring(:c:CustomerName, charindex(',', :c:CustomerName) + 2))),
		i_eg_donor_surname = condition(charindex(',', :c:CustomerName) == 0, NULL,
			substring(:c:CustomerName, 1, charindex(',', :c:CustomerName) - 1)),
		i_eg_donor_middle_name = condition(charindex(',', :c:CustomerName) == 0, NULL,
			condition(charindex(' ', reverse(:c:CustomerName)) == 2, 
				substring(reverse(:c:CustomerName), 1, 1), NULL)),
		i_eg_donor_address = :c:CustomerAddr1+condition(char_length(:c:CustomerAddr2) < 1, '', ' '+:c:CustomerAddr2)+' '+:c:CustomerCity+' '
			+:c:CustomerState+' '+:c:CustomerZip+' '+:c:CustomerCountry,
		i_eg_donor_addr1 = :c:CustomerAddr1,
		i_eg_donor_addr2 = condition(char_length(:c:CustomerAddr2) < 1, NULL, :c:CustomerAddr2),
		i_eg_donor_city = :c:CustomerCity,
		i_eg_donor_state = :c:CustomerState,
		i_eg_donor_postal = :c:CustomerZip,
		i_eg_donor_country = :c:CustomerCountry,
		i_eg_donor_phone = condition(char_length(:c:CustomerPhone) < 1, NULL, :c:CustomerPhone),
		i_eg_donor_email = condition(char_length(:c:CustomerEmail) < 1, NULL, :c:CustomerEmail),
		i_eg_gift_amount = convert('money', :t:FundAmount),
		i_eg_net_amount = condition(char_length(:t:FundTransactionFee) > 1, 
			convert('money', :t:FundAmount) - convert('money', :t:FundTransactionFee),
			convert('money', :t:FundAmount)),
		i_eg_deposit_gross_amt = convert('money', :t:Amount),
		i_eg_deposit_amt = condition(char_length(:t:TransactionFee) > 1, 
			convert('money', :t:Amount) - convert('money', :t:TransactionFee),
			convert('money', :t:Amount)),
		i_eg_deposit_date = condition(char_length(:t:DepositDate)<1, convert('datetime', NULL), convert('datetime', :t:DepositDate)),
		i_eg_deposit_status = NULL, -- TODO: what is this the status of
		i_eg_deposit_uuid = condition(char_length(:t:DepositDate) < 1, NULL, replace(:t:DepositDate, '-', NULL)),
		i_eg_gift_pmt_type = condition(:p:AccountType == 'C' OR :p:AccountType == 'S', 'ACH', 
					condition(upper(:p:CardType) == 'VISA', 'Visa',
					condition(upper(:p:CardType) == 'MASTERCARD', 'MasterCard',
					condition(upper(:p:CardType) == 'AMERICAN EXPRESS', 'Amex',
					condition(upper(:p:CardType) == 'DISCOVER', 'Discover',
					:p:CardType
					))))),
		i_eg_gift_interval = isnull(upper(:o:FrequencyType), ''), -- Monthly, quaterly, and annual all line up.
		i_eg_gift_start_date = condition(char_length(:o:StartDate) > 1, convert('datetime', :o:StartDate), convert('datetime', NULL)),
		i_eg_gift_end_date = condition(char_length(:o:EndDate) > 1, convert('datetime', :o:EndDate), convert('datetime', NULL)),
		i_eg_gift_count = NULL,
		i_eg_gift_date = convert('datetime', :t:ProcessDate),
		i_eg_gift_trx_date = convert('datetime', :t:ProcessDate),
		i_eg_gift_settlement_date = convert('datetime', :t:SettlementDate), 
		i_eg_gift_lastfour = substring(:p:AccountNumber, char_length(:p:AccountNumber) - 3),
		i_eg_desig_name = :t:FundID, -- FIXME: currently the name and uuid need to be set the same. :t:FundName is lost for now? 
		i_eg_desig_notes = condition(char_length(:t:FundNote) < 1, NULL, :t:FundNote) -- potentially include :t:FundName?
	    FROM
		IDENTITY COLLECTION transactions t,
		COLLECTION customers c,
		COLLECTION payMethods p,
		COLLECTION ongoingTransactions o
	    WHERE
		:t:CustomerRef = :c:CustomerRef 
		AND :t:CustomerRef *= :p:CustomerRef 
		AND :t:PaymentMethodRef *= :p:PaymentMethodRef
		AND :t:TransactionRef *= :o:TransactionRef
		AND :t:FundAmount *= :o:Amount
		AND upper(:t:FundName) *= upper(:o:FundName)
	    ;
            ";
	
    }