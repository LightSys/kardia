$Version=2$
plugin_rcpt_importprocess_050splitTrx "system/query"
    {
    module_sequence=50; // want to run before matching
    module_letter='S';
    module_code='Split';
    module_desc='Split combined gifts comming from bill pay transactions';
    // just an example of how to specify a module config component:
    // module_config_cmp='/apps/kardia/modules/rcpt/field_donor_with_new.cmp';

    ledger "query/parameter" { type=string; }

    sql = "
		-- find the designation 
		DECLARE OBJECT splitDesig;
		SELECT
		    :splitDesig:value = 
			(
			select first(:a_config_value)
			from /apps/kardia/data/Kardia_DB/a_config/rows
			where :a_config_name = 'EgSplitDesig'
			)
		;

		-- get all of the sets of transactions that could be transactions that were already split
		DECLARE COLLECTION match;
		INSERT INTO
		    COLLECTION match
		SELECT
		    *
		FROM 
		    /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows 
		WHERE 
		    :i_eg_gift_amount < :i_eg_deposit_gross_amt -- make sure was split into multiple
		GROUP BY
		    :i_eg_line_item, :i_eg_donor_uuid, :i_eg_gift_amount, :i_eg_net_amount, 
		    :i_eg_deposit_amt, :i_eg_deposit_gross_amt, :i_eg_desig_uuid, :i_eg_desig_notes
		;

		-- Find all of the marked queries, split them into multiple, and insert into collection
		-- try to match the queries with an existing transaction. If can't, will need manually done. 
		-- TODO: there is no real reson to allow this to be here
		DECLARE COLLECTION split;
		INSERT INTO 
		    COLLECTION split
		SELECT 
		    -- debug
		    split_trx = :s:i_eg_trx_uuid,
		    match_trx = :m:i_eg_trx_uuid,
		    :s:i_eg_gift_uuid,
		    :m:i_eg_desig_uuid,
		    --:i:i_eg_desig_uuid, -- TODO: need to find a way to let desig be the same without messing up net values on updates
		    :m:i_eg_line_item,
		    :s:i_eg_trx_uuid,
		    :s:i_eg_donor_uuid,
		    :s:i_eg_donor_alt_id,
		    :s:i_eg_account_uuid,
		    :s:i_eg_status,
		    :s:i_eg_returned_status,
		    :s:i_eg_donor_name,
		    :s:i_eg_donor_given_name,
		    :s:i_eg_donor_surname,
		    :s:i_eg_donor_middle_name,
		    :s:i_eg_donor_prefix,
		    :s:i_eg_donor_suffix,
		    :s:i_eg_donor_address,
		    :s:i_eg_donor_addr1,
		    :s:i_eg_donor_addr2,
		    :s:i_eg_donor_addr3,
		    :s:i_eg_donor_city,
		    :s:i_eg_donor_state,
		    :s:i_eg_donor_postal,
		    :s:i_eg_donor_country,
		    :s:i_eg_donor_phone,
		    :s:i_eg_donor_email,
		    :m:i_eg_gift_amount,
		    :m:i_eg_net_amount,
		    :s:i_eg_deposit_gross_amt,
		    :s:i_eg_deposit_amt,
		    :s:i_eg_deposit_date,
		    :s:i_eg_deposit_status, 
		    :s:i_eg_deposit_uuid,
		    :s:i_eg_gift_pmt_type,
		    :s:i_eg_gift_interval,
		    :s:i_eg_gift_start_date,
		    :s:i_eg_gift_end_date,
		    :s:i_eg_gift_count,
		    :s:i_eg_gift_date,
		    :s:i_eg_gift_trx_date,
		    :s:i_eg_gift_settlement_date, 
		    :s:i_eg_gift_lastfour,
		    :m:i_eg_desig_name,
		    :s:i_eg_desig_notes,
		    i_eg_postprocess = substring(:s:i_eg_postprocess, 2),	-- may need post processing from later modules
		    :s:i_eg_service,
		    :s:i_eg_processor,
		    :s:i_eg_gift_currency,
		    :s:i_eg_receipt_desired,
		    :s:i_eg_anonymous,
		    :s:i_eg_prayforme,
		    :s:i_eg_acctmap_future,
		    :s:i_eg_fundmap_future,
		    :s:i_eg_donormap_future,
		    :s:a_ledger_number,
		    s_date_created = getdate(),
		    s_created_by = user_name(),
		    s_date_modified = getdate(),
		    s_modified_by = user_name()
		FROM
		    IDENTITY /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows s,	-- the transactions to split
		    COLLECTION match m 							-- the existig values to match with
		WHERE
		    substring(:s:i_eg_postprocess, 1, 1) = 'S'
		    AND substring(:m:i_eg_postprocess, 1, 1) != 'S' -- the query matching to should have already been processed. 
		    AND isnull(:s:i_eg_desig_notes, '') = isnull(:m:i_eg_desig_notes,'') -- make sure what donor sent was the same
		    AND :s:i_eg_donor_uuid = :m:i_eg_donor_uuid -- make sure was the same donor
		    AND :s:i_eg_deposit_amt = :m:i_eg_deposit_amt
		    AND :s:i_eg_deposit_gross_amt = :m:i_eg_deposit_gross_amt
		    AND :m:i_eg_gift_amount < :m:i_eg_deposit_gross_amt -- make sure was split into multiple
		    AND :s:i_eg_deposit_amt = :s:i_eg_net_amount -- make sure only one item in transaction to be split
		    AND :s:i_eg_deposit_gross_amt = :s:i_eg_gift_amount
		    AND :s:i_eg_deposit_amt IS NOT NULL
		    AND :s:i_eg_net_amount IS NOT NULL
		;
	
		-- transactions will always sum properly since it was a matching condition given above
		-- list all of the i_eg_trx_uuid values
		DECLARE COLLECTION trx_uuids;
		INSERT INTO
		    COLLECTION trx_uuids
		SELECT
		    :s:i_eg_trx_uuid
		FROM
		    COLLECTION split s
		GROUP BY 
		    :s:i_eg_trx_uuid
		;
	
		-- write the new columns to the table
		INSERT INTO
		    /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows
		SELECT
		    :s:i_eg_trx_uuid,		:s:i_eg_gift_uuid,		:s:i_eg_desig_uuid, :s:i_eg_line_item,
		    :s:i_eg_donor_uuid, 	:s:i_eg_donor_alt_id,		:s:i_eg_account_uuid, :s:i_eg_status,
		    :s:i_eg_returned_status, 	:s:i_eg_donor_name,		:s:i_eg_donor_given_name, 
		    :s:i_eg_donor_surname, 	:s:i_eg_donor_middle_name,	:s:i_eg_donor_prefix,
		    :s:i_eg_donor_suffix, 	:s:i_eg_donor_address,		:s:i_eg_donor_addr1,
		    :s:i_eg_donor_addr2,	:s:i_eg_donor_addr3,		:s:i_eg_donor_city,
		    :s:i_eg_donor_state,	:s:i_eg_donor_postal,		:s:i_eg_donor_country,
		    :s:i_eg_donor_phone,	:s:i_eg_donor_email,		:s:i_eg_gift_amount,
		    :s:i_eg_net_amount,		:s:i_eg_deposit_gross_amt,	:s:i_eg_deposit_amt,
		    :s:i_eg_deposit_date,	:s:i_eg_deposit_status, 	:s:i_eg_deposit_uuid,
		    :s:i_eg_gift_pmt_type,	:s:i_eg_gift_interval,		:s:i_eg_gift_start_date,
		    :s:i_eg_gift_end_date,	:s:i_eg_gift_count,		:s:i_eg_gift_date,
		    :s:i_eg_gift_trx_date,	:s:i_eg_gift_settlement_date,	:s:i_eg_gift_lastfour,
		    :s:i_eg_desig_name,		:s:i_eg_desig_notes,		:s:i_eg_postprocess,
		    :s:i_eg_service,		:s:i_eg_processor,		:s:i_eg_gift_currency,
		    :s:i_eg_receipt_desired,	:s:i_eg_anonymous,		:s:i_eg_prayforme,
		    :s:i_eg_acctmap_future,	:s:i_eg_fundmap_future,		:s:i_eg_donormap_future,
		    :s:a_ledger_number,		:s:s_date_created,		:s:s_created_by,
		    :s:s_date_modified,		:s:s_modified_by
		FROM 
		    COLLECTION split s
		ON DUPLICATE
		    :a_ledger_number, :i_eg_trx_uuid, :i_eg_desig_uuid, :i_eg_line_item
		UPDATE SET
		    :i_eg_deposit_date = :s:i_eg_deposit_date,
		    :i_eg_deposit_uuid = :s:i_eg_deposit_uuid,
		    :i_eg_deposit_gross_amt = :s:i_eg_deposit_gross_amt,
		    :i_eg_deposit_amt = :s:i_eg_deposit_amt,
		    :i_eg_net_amount = :s:i_eg_net_amount,
		    :i_eg_desig_notes = :s:i_eg_desig_notes,
		    :i_eg_status = :s:i_eg_status,
		    :i_eg_returned_status = :s:i_eg_returned_status,
		    :i_eg_gift_settlement_date = :s:i_eg_gift_settlement_date,
		    :s_date_modified = getdate() IF MODIFIED,
		    :s_modified_by = user_name() IF MODIFIED
		;
	
		-- Delete any transactions that have already been split. (i.e. have an id in trx_uuid)
		DELETE 
		FROM
		    IDENTITY /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows i,
		    COLLECTION trx_uuids u
		WHERE 
		    substring(:i_eg_postprocess, 1, 1) = 'S' -- all of the new items won't start with S
		    AND :i:i_eg_trx_uuid = :u:i_eg_trx_uuid  -- limits to just the items worked on
		    AND :i:i_eg_gift_amount = :i:i_eg_deposit_gross_amt -- will be a single transaction
		    AND :i:i_eg_net_amount = :i:i_eg_deposit_amt
		;
	
		-- If it still has an S, can assume that must not have been able to 
		UPDATE 
		    /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows
		SET 
		    :i_eg_postprocess = substring(:i_eg_postprocess, 2)
		WHERE 
		    substring(:i_eg_postprocess, 1, 1) = 'S'
    ";
    }