$Version=2$
plugin_rcpt_importprocess_075feeCombo "system/query"
    {
    module_sequence=75; // want to run before matching
    module_letter='F';
    module_code='Fee';
    module_desc='Combine donations made to cover transaction fees to other gifts in the transaction';

    ledger "query/parameter" { type=string; }
    sql = "
	-- when have a donation to cover transaction fees, just split it across all of the fees that happened with it
	-- code: F for fee
	-- TOOD: add randomness but repeatable (maybe sort by a hashed desig id instead of the actual desig?)
	-- get the designation that indicates the transaction is a fee
	DECLARE OBJECT feeDesig;
		SELECT
		    :feeDesig:value = 
			(
			select first(:a_config_value)
			from /apps/kardia/data/Kardia_DB/a_config/rows
			where :a_config_name = 'EgFeesDesig'
			)
		;

	DECLARE COLLECTION marked;
	INSERT INTO
	    COLLECTION marked 
	SELECT
	    :i_eg_trx_uuid, :i_eg_desig_uuid, :i_eg_gift_amount, 
	    :i_eg_net_amount, :i_eg_deposit_gross_amt, :i_eg_deposit_amt,
	    :a_ledger_number, :i_eg_line_item, :i_eg_postprocess, :i_eg_service
	FROM 
	    /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows
	WHERE 
	    :i_eg_postprocess IS NOT NULL 
	    AND substring(:i_eg_postprocess, 1, 1) == 'F'
	    AND :a_ledger_number = :parameters:ledger
	;

	-- get all of the fees and the transactions that go with them
	DECLARE COLLECTION feeSets;
	INSERT INTO
	    COLLECTION feeSets
	SELECT 
	    :t:i_eg_trx_uuid, :t:i_eg_desig_uuid, :t:i_eg_gift_amount, 
	    :t:i_eg_net_amount, :t:i_eg_deposit_gross_amt, :t:i_eg_deposit_amt,
	    :t:a_ledger_number, :t:i_eg_line_item, :t:i_eg_service,
	    fee_trx = :f:i_eg_trx_uuid, 
	    fee_desig = :f:i_eg_desig_uuid, 
	    fee_grs = :f:i_eg_gift_amount, 
	    fee_net = :f:i_eg_net_amount,
	    -- get the share values for fees
	    fee_share_grs = convert('double', :f:i_eg_gift_amount) * :t:i_eg_gift_amount / (:t:i_eg_deposit_gross_amt - :f:i_eg_gift_amount),
	    fee_share_net = convert('double', :f:i_eg_net_amount) * :t:i_eg_net_amount / (:t:i_eg_deposit_amt - :f:i_eg_net_amount),
	    cents_grs = 0,
	    cents_net = 0,
	    ind_net = -1,
	    ind_grs = -1
	FROM 
	    IDENTITY COLLECTION marked f,
	    COLLECTION marked t
	WHERE 
	    :f:i_eg_desig_uuid = :feeDesig:value
	    AND :t:i_eg_trx_uuid = :f:i_eg_trx_uuid
	    AND :t:i_eg_service = :f:i_eg_service
	    AND :t:i_eg_desig_uuid != :feeDesig:value
	    AND :f:i_eg_deposit_amt IS NOT NULL
	    AND :f:i_eg_net_amount IS NOT NULL
	;

	-- calculate the number of cents that will be leftover
	DECLARE COLLECTION leftoverCents;
	INSERT INTO 
	    COLLECTION leftoverCents
	SELECT
	    grs = convert('integer', round(100 * (:fee_grs - sum(truncate(:i:fee_share_grs, 2))), 0)),
	    net = convert('integer', round(100 * (:fee_net - sum(truncate(:i:fee_share_net, 2))), 0)),
	    :i:i_eg_trx_uuid, :i:i_eg_service
	FROM COLLECTION feeSets i
	GROUP BY
	    :i:i_eg_trx_uuid, :i:i_eg_service
	;

	-- join leftover data to the feeSets
	UPDATE
	    IDENTITY COLLECTION feeSets f,
	    COLLECTION leftoverCents l
	SET
	    :f:cents_grs = :l:grs,
	    :f:cents_net = :l:net
	WHERE
	    :l:i_eg_trx_uuid = :f:i_eg_trx_uuid	
	    AND :l:i_eg_service = :f:i_eg_service
	;
	
	-- no longer needed so clear
	DELETE FROM COLLECTION leftoverCents;

	-- set an index for every gross share that has a fractional amount missing
	DECLARE COLLECTION grossIndex;
	INSERT INTO 
	    COLLECTION grossIndex
	SELECT 
	    ind = row_number(:i_eg_trx_uuid+:i_eg_service),
	    :i_eg_desig_uuid,
	    :i_eg_trx_uuid,
	    :i_eg_line_item,
	    :i_eg_service
	FROM 
	    COLLECTION feeSets
	WHERE 
	    :fee_share_grs - truncate(:fee_share_grs, 2) > 0
	;

	-- now handle net
	DECLARE COLLECTION netIndex;
	INSERT INTO 
	    COLLECTION netIndex
	SELECT 
	    ind = row_number(:i_eg_trx_uuid+:i_eg_service),
	    :i_eg_desig_uuid,
	    :i_eg_trx_uuid,
	    :i_eg_line_item,
	    :i_eg_service
	FROM 
	    COLLECTION feeSets
	WHERE 
	    :fee_share_net - truncate(:fee_share_net, 2) > 0
	;

	-- update with the new information
	UPDATE
	    IDENTITY COLLECTION feeSets f,
	    COLLECTION netIndex n,
	    COLLECTION grossIndex g
	SET
	    :f:ind_net = :n:ind,
	    :f:ind_grs = :g:ind
	WHERE
	    :f:i_eg_trx_uuid *= :g:i_eg_trx_uuid
	    AND :f:i_eg_desig_uuid *= :g:i_eg_desig_uuid
	    AND :f:i_eg_line_item *= :g:i_eg_line_item
	    AND :f:i_eg_service *= :g:i_eg_service
	    AND :f:i_eg_trx_uuid *= :n:i_eg_trx_uuid
	    AND :f:i_eg_desig_uuid *= :n:i_eg_desig_uuid
	    AND :f:i_eg_line_item *= :n:i_eg_line_item
	    AND :f:i_eg_service *= :n:i_eg_service
	;

	-- clear out uneeded collections
	DELETE FROM COLLECTION grossIndex;
	DELETE FROM COLLECTION netIndex;

	-- update collection with calculated fee splits
	UPDATE
	    COLLECTION feeSets
	SET
	    :i_eg_gift_amount = condition(:ind_grs IS NOT NULL,
		condition(:ind_grs <= :cents_grs,
		    :i_eg_gift_amount + truncate(:fee_share_grs, 2) + 0.01,
		    :i_eg_gift_amount + truncate(:fee_share_grs, 2)
		    ),
		:i_eg_gift_amount + :fee_share_grs
		),
	    :i_eg_net_amount = condition(:ind_net IS NOT NULL,
		condition(:ind_net <= :cents_net,
		    :i_eg_net_amount + truncate(:fee_share_net, 2) + 0.01,
		    :i_eg_net_amount + truncate(:fee_share_net, 2)
		    ),
		:i_eg_net_amount + :fee_share_net
		)
	;

	-- confirm the checksums
	DECLARE COLLECTION checksum;
	INSERT INTO 
	    COLLECTION checksum
	SELECT
	   grs_sum = sum(:i_eg_gift_amount),
	   net_sum = sum(:i_eg_net_amount),
	   :i_eg_deposit_gross_amt,
	   :i_eg_deposit_amt,
	   :i_eg_trx_uuid,
	   :i_eg_service
	FROM 
	    COLLECTION feeSets
	GROUP BY
	    :i_eg_trx_uuid,
	    :i_eg_service
	;

	-- Remove any transactions that don't sum properly 
	DELETE FROM
	    IDENTITY COLLECTION feeSets f, 
	    COLLECTION checksum c
	WHERE
	    :f:i_eg_trx_uuid = :c:i_eg_trx_uuid
	    AND :f:i_eg_service = :c:i_eg_service
	    AND (:c:i_eg_deposit_gross_amt != :c:grs_sum 
		OR :c:i_eg_deposit_amt != :c:net_sum)
	;

	-- update the values in the actual tables (must update even if no F; upsert reverts changes otherwise)
	UPDATE
	    IDENTITY /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows i,
	    COLLECTION feeSets f
	SET
	    :i:i_eg_gift_amount = :f:i_eg_gift_amount,
	    :i:i_eg_net_amount = :f:i_eg_net_amount
	WHERE 
	    :i:i_eg_trx_uuid = :f:i_eg_trx_uuid 
	    AND :i:a_ledger_number = :f:a_ledger_number
	    AND :i:i_eg_desig_uuid = :f:i_eg_desig_uuid
	    AND :i:i_eg_line_item = :f:i_eg_line_item
	    AND :i:i_eg_service = :f:i_eg_service
	;
	

	-- delete the 'cover fees' entries that are in the list of updated transactions
	DELETE FROM
	    IDENTITY /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows i,
	    COLLECTION feeSets f
	WHERE 
	    :i:i_eg_trx_uuid = :f:i_eg_trx_uuid 
	    AND :i:a_ledger_number = :f:a_ledger_number
	    AND :i:i_eg_service = :f:i_eg_service
	    AND substring(:i:i_eg_postprocess, 1, 1) = 'F'
	    AND :i:i_eg_desig_uuid = :feeDesig:value
	GROUP BY
	    -- only want to try and delete it once
	    :i:i_eg_trx_uuid, :i:i_eg_service
	;

	 -- remove the F if could have run, and move to back if waiting on net amounts
	update
	    /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows
	set
	    :i_eg_postprocess = condition((:i_eg_deposit_amt IS NOT NULL AND :i_eg_net_amount IS NOT NULL),
		substring(:i_eg_postprocess, 2),
		substring(:i_eg_postprocess, 2) + 'F'
		)
	where
	    substring(:i_eg_postprocess, 1, 1) = 'F'
	    AND :a_ledger_number = :parameters:ledger
	
    ";
    }