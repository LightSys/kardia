$Version=2$
plugin_rcpt_importprocess_075feeCombo "system/query"
    {
    module_sequence=75; // want to run before matching
    module_letter='F';
    module_code='Fee';
    module_desc='Combine donations made to cover transaction fees to other gifts in the transaction';

    ledger "query/parameter" { type=string; }
    sql = "
	-- when have a donation to cover transaction fees, just split it across all of the fees that happened with it
	-- code: F for fee
	-- TOOD: add randomness but repeatable (maybe sort by a hashed desig id instead of the actual desig)
	-- get the designation that indicates the transaction is a fee
	DECLARE OBJECT feeDesig;
		SELECT
		    :feeDesig:value = 
			(
			select first(:a_config_value)
			from /apps/kardia/data/Kardia_DB/a_config/rows
			where :a_config_name = 'EgFeesDesig'
			)
		;

	DECLARE COLLECTION marked;
	INSERT INTO
	    COLLECTION marked 
	SELECT
	    *
	FROM 
	    /apps/kardia/modules/rcpt/plugin_rcpt_sub_importprocess_findMarked.qy?module_letter=F
	;

	-- get all of the fees and the transactions that go with them
	DECLARE COLLECTION feeSets;
	INSERT INTO
	    COLLECTION feeSets
	SELECT 
	    :t:i_eg_trx_uuid, :t:i_eg_desig_uuid, :t:i_eg_gift_amount, 
	    :t:i_eg_net_amount, :t:i_eg_deposit_gross_amt, :t:i_eg_deposit_amt,
	    :t:a_ledger_number, :t:i_eg_line_item, 
	    fee_trx = :f:i_eg_trx_uuid, 
	    fee_desig = :f:i_eg_desig_uuid, 
	    fee_grs = :f:i_eg_gift_amount, 
	    fee_net = :f:i_eg_net_amount,
	    -- get the share values for fees
	    fee_share_grs = convert('double', :f:i_eg_gift_amount) * :t:i_eg_gift_amount / (:t:i_eg_deposit_gross_amt - :f:i_eg_gift_amount),
	    fee_share_net = convert('double', :f:i_eg_net_amount) * :t:i_eg_net_amount / (:t:i_eg_deposit_amt - :f:i_eg_net_amount),
	    cents_grs = 0,
	    cents_net = 0,
	    ind_net = -1,
	    ind_grs = -1
	FROM 
	    IDENTITY COLLECTION marked f,
	    COLLECTION marked t
	WHERE 
	    :f:i_eg_desig_uuid = :feeDesig:value
	    AND :t:i_eg_trx_uuid = :f:i_eg_trx_uuid
	    AND :t:i_eg_desig_uuid != :feeDesig:value
	    AND substring(:f:i_eg_postprocess, 1, 1) = 'F'
	    AND :f:i_eg_deposit_amt IS NOT NULL
	    AND :f:i_eg_net_amount IS NOT NULL
	;
print 'done'
	-- calculate the number of cents that will be leftover
	DECLARE COLLECTION leftoverCents;
	INSERT INTO 
	    COLLECTION leftoverCents
	SELECT
	    grs = convert('integer', round(100 * sum(:i:fee_share_grs - truncate(:i:fee_share_grs, 2)),0)),
	    net = convert('integer', round(100 * sum(:i:fee_share_net - truncate(:i:fee_share_net, 2)),0)),
	    :i:i_eg_trx_uuid
	FROM COLLECTION feeSets i
	GROUP BY
	    :i:i_eg_trx_uuid
	;

	-- join leftover data to the feeSets
	UPDATE
	    IDENTITY COLLECTION feeSets f,
	    COLLECTION leftoverCents l
	SET
	    :f:cents_grs = :l:grs,
	    :f:cents_net = :l:net
	WHERE
	    :l:i_eg_trx_uuid = :f:i_eg_trx_uuid	
	;
	
	-- no longer needed so clear
	DELETE FROM COLLECTION leftoverCents;

	-- set an index for every gross share that has a fractional amount missing
	DECLARE COLLECTION grossIndex;
	INSERT INTO 
	    COLLECTION grossIndex
	SELECT 
	    ind = row_number(:i_eg_trx_uuid),
	    :i_eg_desig_uuid,
	    :i_eg_trx_uuid,
	    :i_eg_line_item
	FROM 
	    COLLECTION feeSets
	WHERE 
	    :fee_share_grs - truncate(:fee_share_grs, 2) > 0
	;

	-- now handle net
	DECLARE COLLECTION netIndex;
	INSERT INTO 
	    COLLECTION netIndex
	SELECT 
	    ind = row_number(:i_eg_trx_uuid),
	    :i_eg_desig_uuid,
	    :i_eg_trx_uuid,
	    :i_eg_line_item
	FROM 
	    COLLECTION feeSets
	WHERE 
	    :fee_share_net - truncate(:fee_share_net, 2) > 0
	;

	-- update with the new information
	UPDATE
	    IDENTITY COLLECTION feeSets f,
	    COLLECTION netIndex n,
	    COLLECTION grossIndex g
	SET
	    :f:ind_net = :n:ind,
	    :f:ind_grs = :g:ind
	WHERE
	    :f:i_eg_trx_uuid *= :g:i_eg_trx_uuid
	    AND :f:i_eg_desig_uuid *= :g:i_eg_desig_uuid
	    AND :f:i_eg_line_item *= :g:i_eg_line_item
	    AND :f:i_eg_trx_uuid *= :n:i_eg_trx_uuid
	    AND :f:i_eg_desig_uuid *= :n:i_eg_desig_uuid
	    AND :f:i_eg_line_item *= :n:i_eg_line_item
	;


	-- clear out uneeded collections
	DELETE FROM COLLECTION grossIndex;
	DELETE FROM COLLECTION netIndex;

	-- update the values in the actual tables (must update even if no F; upsert reverts changes otherwise)
	UPDATE
	    IDENTITY /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows i,
	    COLLECTION feeSets f
	SET
	    -- gross does not update, so need to only run if marked
	    :i:i_eg_gift_amount = condition(substring(:i_eg_postprocess, 1, 1) = 'F',
		condition(:f:ind_grs IS NOT NULL,
		    condition(:f:ind_grs <= :f:cents_grs,
			:i:i_eg_gift_amount + truncate(:f:fee_share_grs, 2) + 0.01,
			:i:i_eg_gift_amount + truncate(:f:fee_share_grs, 2)
			),
		    :i:i_eg_gift_amount + :f:fee_share_grs
		    ),
		:i:i_eg_gift_amount
		),
	    -- net amount gets overwritten by update, so always needs to run again
	    :i:i_eg_net_amount = condition(:f:ind_net IS NOT NULL,
		    condition(:f:ind_net <= :f:cents_net,
			:i:i_eg_net_amount + truncate(:f:fee_share_net, 2) + 0.01,
			:i:i_eg_net_amount + truncate(:f:fee_share_net, 2)
			),
		    :i:i_eg_net_amount + :f:fee_share_net
		    )
	WHERE 
	    :i:i_eg_trx_uuid = :f:i_eg_trx_uuid 
	    AND :i:a_ledger_number = :f:a_ledger_number
	    AND :i:i_eg_desig_uuid = :f:i_eg_desig_uuid
	    AND :i:i_eg_line_item = :f:i_eg_line_item
	;
	

	-- delete the 'cover fees' entries that are in the list of updated transactions
	DELETE FROM
	    IDENTITY /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows i,
	    COLLECTION feeSets f
	WHERE 
	    :i:i_eg_trx_uuid = :f:i_eg_trx_uuid 
	    AND :i:a_ledger_number = :f:a_ledger_number
	    AND substring(:i:i_eg_postprocess, 1, 1) = 'F'
	    AND :i:i_eg_desig_uuid = :feeDesig:value
	GROUP BY
	    -- only want to try and delete it once
	    :i:i_eg_trx_uuid
	;

	 -- remove the F if could have run, and move to back if waiting on net amounts
	update
	    /apps/kardia/data/Kardia_DB/i_eg_gift_import/rows
	set
	    :i_eg_postprocess = condition((:i_eg_deposit_amt IS NOT NULL AND :i_eg_net_amount IS NOT NULL),
		substring(:i_eg_postprocess, 2),
		substring(:i_eg_postprocess, 2) + 'F'
		)
	where
	    substring(:i_eg_postprocess, 1, 1) = 'F'
	
    ";
    }